<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · PowerModelsDistribution</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="PowerModelsDistribution logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PowerModelsDistribution</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../installation.html">Installation Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/quickguide.html">Getting Started</a></li><li><a class="tocitem" href="../manual/external-data-formats.html">External Data Formats</a></li><li><a class="tocitem" href="../manual/eng-data-model.html">Engineering Data Model</a></li><li><a class="tocitem" href="../manual/enums.html">Enums in Engineering Model</a></li><li><a class="tocitem" href="../manual/math-model.html">Mathematical Model</a></li><li><a class="tocitem" href="../manual/eng2math.html">Conversion to Mathematical Model</a></li><li><a class="tocitem" href="../manual/formulations.html">Unbalanced Formulations</a></li><li><a class="tocitem" href="../manual/specifications.html">Problem Specifications</a></li><li><a class="tocitem" href="../manual/load-model.html">Load Models</a></li><li><a class="tocitem" href="../manual/connections.html">Connecting Components</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/Beginners Guide.html">Beginners Guide</a></li><li><a class="tocitem" href="../tutorials/The Engineering Model.html">The Engineering Data Model</a></li><li><a class="tocitem" href="../tutorials/Engineering Model - Helper Functions.html">Engineering Model: Helper Functions</a></li><li><a class="tocitem" href="../tutorials/basic.html">Basics</a></li><li><a class="tocitem" href="../tutorials/Extension Tutorial.html">Extending PowerModelsDistribution</a></li><li><a class="tocitem" href="../tutorials/Explicit Neutral Models.html">Explicit Neutral Models</a></li><li><a class="tocitem" href="../tutorials/Native Power Flow.html">Native Power Flow Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Base</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="data_models.html">Data Models</a></li><li><a class="tocitem" href="enums.html">Enums</a></li><li><a class="tocitem" href="formulations.html">Formulations</a></li><li><a class="tocitem" href="problems.html">Problems</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li class="is-active"><a class="tocitem" href="constraints.html">Constraints</a><ul class="internal"><li><a class="tocitem" href="#Relaxation-Helpers"><span>Relaxation Helpers</span></a></li><li><a class="tocitem" href="#Miscellaneous-Helpers"><span>Miscellaneous Helpers</span></a></li></ul></li><li><a class="tocitem" href="objectives.html">Objectives</a></li><li><a class="tocitem" href="constants.html">Constants</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../developer/extensions.html">Extensions</a></li><li><a class="tocitem" href="../developer/contributing.html">Contributing</a></li><li><a class="tocitem" href="../developer/style.html">Style Guide</a></li><li><a class="tocitem" href="../developer/roadmap.html">Roadmap</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="constraints.html">Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="constraints.html">Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/main/docs/src/reference/constraints.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ConstraintAPI"><a class="docs-heading-anchor" href="#ConstraintAPI">Constraints</a><a id="ConstraintAPI-1"></a><a class="docs-heading-anchor-permalink" href="#ConstraintAPI" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_M_psd-Tuple{JuMP.Model, Any, Any}" href="#PowerModelsDistribution.constraint_M_psd-Tuple{JuMP.Model, Any, Any}"><code>PowerModelsDistribution.constraint_M_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For rectangular coordinates of a complex matrix M=M<em>re+im*M</em>im, this function applies constraints equivalent to requiring that M itself is PSD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L1007-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_SWL_psd-Tuple{JuMP.Model, Vararg{Any, 6}}" href="#PowerModelsDistribution.constraint_SWL_psd-Tuple{JuMP.Model, Vararg{Any, 6}}"><code>PowerModelsDistribution.constraint_SWL_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take a multi-conductor voltage variable V and a current variable I. The associated power is then defined as S = V<em>I^H Define the lifted variables as W and L as W = V</em>V^H, L = I*I^H Then, it is equally valid that [W S; S^H L] ∈ PSDCone, rank([W S; S^H L])=1 This function adds this PSD constraint for the rectangular coordinates of S, W and L.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L990-L999">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_capacitor_on_off(pm::AbstractUnbalancedACPModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  v-v_\text{min} ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } v-v_\text{max} ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L583-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_capacitor_on_off(pm::AbstractUnbalancedACRModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  v_r^2 + v_i^2 - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } v_r^2 + v_i^2 - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L599-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_capacitor_on_off(pm::AbstractUnbalancedIVRModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control: } s = (vr_fr+im*vi_fr).*(cr_fr-im*ci_fr),\\
&amp;\text{kvar control (ON): }  \Im{s}-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } \Im{s}-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  v_r^2 + v_i^2 - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } v_r^2 + v_i^2 - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L380-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_capacitor_on_off(pm::FBSUBFPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  2 ⋅ v_{r0} ⋅ v_r + 2 ⋅ v_{i0} ⋅ v_i - v_{r0}^2 - v_{i0}^2 - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } 2 ⋅ v_{r0} ⋅ v_r + 2 ⋅ v_{i0} ⋅ v_i - v_{r0}^2 - v_{i0}^2 - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L440-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_capacitor_on_off(pm::FOTRUPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching similar to FBSUBFPowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L331-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_capacitor_on_off(pm::LPUBFDiagModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  w - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } w - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L280-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_from(pm::AbstractUnbalancedACPModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq vm_{fr}^2 i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1282-L1290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_from(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for branch current limit constraint from-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1072-L1076">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_from(pm::AbstractUnbalancedRectangularModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq (vr_{fr}^2 + vi_{fr}^2) i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L1119-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_from(pm::AbstractUnbalancedWModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq w_{fr} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L364-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{LPUBFDiagModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{LPUBFDiagModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_from(pm::AbstractUnbalancedWModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq w_{fr} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L580-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_to(pm::AbstractUnbalancedACPModel, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq vm_{to}^2 i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1306-L1314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_to(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothin</code></pre><p>Template function for branch current limit constraint to-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1092-L1096">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_to(pm::AbstractUnbalancedRectangularModels, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq (vr_{to}^2 + vi_{to}^2) i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L1144-L1152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_to(pm::AbstractUnbalancedWModels, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq w_{to} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L388-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{LPUBFDiagModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{LPUBFDiagModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ampacity_to(pm::AbstractUnbalancedWModels, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq w_{to} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L625-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector, Vector, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector, Vector, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_branch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_branch_current_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector,
	t_connections::Vector,
	c_rating::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the total current magnitude per conductor.</p><pre><code class="nohighlight hljs">p_fr^2 + q_fr^2 &lt;= r^2 * (vr_fr^2 + vi_fr^2)
p_to^2 + q_to^2 &lt;= r^2 * (vr_to^2 + vi_to^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L624-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector, Vector, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector, Vector, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_branch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_branch_current_limit(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector,
	t_connections::Vector,
	c_rating::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the current magnitude per conductor at both ends of the branch (total current, i.e. including shunt contributions).</p><pre><code class="nohighlight hljs">cr_fr^2 + ci_fr^2 &lt;= c_rating^2
cr_to^2 + ci_to^2 &lt;= c_rating^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1380-L1400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_branch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_branch_current_limit(
	pm::ExplicitNeutralModels,
	id::Int;
	nw::Int=nw_id_default,
	bounded::Bool=true,
	report::Bool=true,
)</code></pre><p>For models with explicit neutrals, imposes a bound on the current magnitude per conductor at both ends of the branch (total current, i.e. including shunt contributions)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L922-L934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_series_product_hermitian-Tuple{AbstractUBFModels}" href="#PowerModelsDistribution.constraint_mc_branch_current_series_product_hermitian-Tuple{AbstractUBFModels}"><code>PowerModelsDistribution.constraint_mc_branch_current_series_product_hermitian</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_flow-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_branch_flow-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_branch_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Already handled by variable<em>mc</em>branch<em>power</em>real</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_flow-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_branch_flow-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_branch_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_branch_flow(pm::AbstractUnbalancedPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>For superconducting branch flow (br<em>r and br</em>x all zeros)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L268-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_balance(pm::AbstractUnbalancedPowerModel, bus_id::Int; nw=nw_id_default)::Nothing</code></pre><p>Template function for bus voltage balance constraints.</p><p>Impose all balance related constraints for which key present in data model of bus. For a discussion of sequence components and voltage unbalance factor (VUF), see @INPROCEEDINGS{girigoudar<em>molzahn</em>roald-2019, 	author={K. Girigoudar and D. K. Molzahn and L. A. Roald}, 	booktitle={submitted}, 	title={{Analytical and Empirical Comparisons of Voltage Unbalance Definitions}}, 	year={2019}, 	month={},     url={https://molzahn.github.io/pubs/girigoudar<em>molzahn</em>roald-2019.pdf} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_drop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_bus_voltage_drop(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	i::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	r::Matrix{&lt;:Real},
	x::Matrix{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, defines voltage drop over a branch, linking from and to side complex voltage.</p><pre><code class="nohighlight hljs">vr_to == vr_fr - r*csr_fr + x*csi_fr
vi_to == vi_fr - r*csi_fr - x*csr_fr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1343-L1364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_drop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines voltage drop over a branch, linking from and to side complex voltage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_drop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_drop(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for bus voltage drop constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L681-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_ll-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector, Vector}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_ll-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector, Vector}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_ll</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1021">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_negative_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_negative_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_negative_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L873-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage magnitude constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_on_off(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})::Nothing</code></pre><p>Generic on/off bus voltage magnitude constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for on/off voltage magnitude constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_positive_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_positive_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_positive_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L908-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage magnitude squared constraint for relaxed formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_sqr_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for on/off voltage magnitude squared constraint for relaxed formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_vuf-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_vuf-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_vuf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L826-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_zero_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_zero_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_zero_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L943-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACPModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACPModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bus voltage on/off constraint for load shed problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACRModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACRModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bus voltage on/off constraint for load shed problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedDCPModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedDCPModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage constraint for DCP formulation, nothing to do</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_on_off(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for on/off constraint for bus voltages&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedWModels}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedWModels}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage constraint for relaxed forms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_current_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kirchhoff&#39;s current law applied to buses <code>sum(cr + im*ci) = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L261-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_current_balance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints in current-voltage variable space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_current_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_current_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_current_balance(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_gens::Vector{Tuple{Int,Vector{Int}}},
	bus_storage::Vector{Tuple{Int,Vector{Int}}},
	bus_loads::Vector{Tuple{Int,Vector{Int}}},
	bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>Kirchhoff&#39;s current law applied to buses <code>sum(cr + im*ci) = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L95-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance_capc-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_current_balance_capc-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_current_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_current_balance_capc(pm::AbstractUnbalancedIVRModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Current balance constraints with capacitor control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance_capc-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_balance_capc-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_current_balance_capc(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints in current-voltage variable space with capacitor control variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L398-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_current_from(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	g_sh_fr::Matrix{&lt;:Real},
	b_sh_fr::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="nohighlight hljs">cr_fr == csr_fr + g_sh_fr*vr_fr - b_sh_fr*vi_fr
ci_fr == csi_fr + g_sh_fr*vi_fr + b_sh_fr*vr_fr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1254-L1273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines how current distributes over series and shunt impedances of a pi-model branch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_current_from(pm::AbstractUnbalancedIVRModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for current constraints on branches (from-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L642-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{ReducedExplicitNeutralIVRModels, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{ReducedExplicitNeutralIVRModels, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_current_from(
	pm::ReducedExplicitNeutralIVRModels,
	nw::Int,
	f_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	g_sh_fr::Matrix{&lt;:Real},
	b_sh_fr::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For branch-reduced IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="nohighlight hljs">cr_fr = csr_fr + g_sh_fr*vr_fr - b_sh_fr*vi_fr
ci_fr = csi_fr + g_sh_fr*vi_fr + b_sh_fr*vr_fr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1518-L1537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bounds the current magnitude at both from and to side of a branch <code>cr[f_idx]^2 + ci[f_idx]^2 &lt;= c_rating_a^2</code> <code>cr[t_idx]^2 + ci[t_idx]^2 &lt;= c_rating_a^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_current_to(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	t_bus,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	g_sh_to::Matrix{&lt;:Real},
	b_sh_to::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="nohighlight hljs">cr_to == csr_to + g_sh_to*vr_to - b_sh_to*vi_to
ci_to == csi_to + g_sh_to*vi_to + b_sh_to*vr_to</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1298-L1319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines how current distributes over series and shunt impedances of a pi-model branch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_current_to(pm::AbstractUnbalancedIVRModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for current constraints on branches (to-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L661-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{ReducedExplicitNeutralIVRModels, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{ReducedExplicitNeutralIVRModels, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_current_to(
	pm::ReducedExplicitNeutralIVRModels,
	nw::Int,
	t_bus,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	g_sh_to::Matrix{&lt;:Real},
	b_sh_to::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For branch-reduced IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="nohighlight hljs">cr_to = csr_to + g_sh_to*vr_to - b_sh_to*vi_to
ci_to = csi_to + g_sh_to*vi_to + b_sh_to*vr_to</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1563-L1584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_gen_active_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>pmin &lt;= Re(v*cg&#39;) &lt;= pmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L497-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_active_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_gen_active_bounds(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for defining limits on active power output of a generator where bounds can&#39;t be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L907-L911">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_gen_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off constraint for generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_gen_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off constraint for generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_gen_power_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for generator power on/off constraints (MLD problems)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L888-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_gen_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>pg[i] == pg</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_gen_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_gen_power_setpoint_real(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, pg::Vector{&lt;:Real})::Nothing</code></pre><p>Generic generator real power setpoint constraint</p><p class="math-container">\[P_g == P_g^{setpoint}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_gen_power_setpoint_real(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for generator active power setpoint constraint, for power flow problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L864-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_gen_reactive_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>qmin &lt;= Im(v*cg&#39;) &lt;= qmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L513-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_reactive_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_gen_reactive_bounds(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for defines limits on reactive power output of a generator where bounds can&#39;t be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L920-L924">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_current(
	pm::AbstractExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates expressions for the terminal current flows <code>:crg_bus</code> and <code>:cig_bus</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_generator_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_generator_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_current_delta(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates expressions for the terminal current flows <code>:crg_bus</code> and <code>:cig_bus</code> of delta-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L84-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_generator_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_generator_current_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_current_wye(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates expressions for the terminal current flows <code>:crg_bus</code> and <code>:cig_bus</code> of wye-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L63-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only support wye-connected generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power(pm::AbstractUnbalancedPowerModel, id::Int; nw::Int=nw_id_default, report::Bool=true, bounded::Bool=true)::Nothing</code></pre><p>Template function for generator power constraints</p><p><strong>DELTA</strong></p><p>When connected in delta, the load power gives the reference in the delta reference frame. This means</p><p class="math-container">\[sd_1 = v_ab.conj(i_ab) = (v_a-v_b).conj(i_ab)\]</p><p>We can relate this to the per-phase power by</p><p class="math-container">\[sn_a = v_a.conj(i_a)
    = v_a.conj(i_ab-i_ca)
    = v_a.conj(conj(s_ab/v_ab) - conj(s_ca/v_ca))
    = v_a.(s_ab/(v_a-v_b) - s_ca/(v_c-v_a))\]</p><p>So for delta, sn is constrained indirectly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L820-L844">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{SDPUBFKCLMXModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{SDPUBFKCLMXModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Link the current and power withdrawn by a generator at the bus through a PSD constraint. The rank-1 constraint is dropped in this formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L712-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    report::Bool=true
)</code></pre><p>Constrains generator power variables for models with explicit neutrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power_delta(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, links the terminal power flows <code>:pg_bus</code> and <code>:qg_bus</code> to the power variables <code>:pg</code> and <code>:qg</code> for delta-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L85-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power_delta(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates non-linear expressions for the generator power <code>:pd</code> and <code>:qd</code> of delta-connected generators as a function of voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L168-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power_delta(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, links the generator power variables <code>:pd</code> and <code>:qd</code> of delta-connected generators to the voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L264-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_delta(pm::FBSUBFPowerModel, nw::Int, id::Int, bus_id::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, qmin::Vector{&lt;:Real}, qmax::Vector{&lt;:Real}; report::Bool=true, bounded::Bool=true)</code></pre><p>Adds constraints for delta-connected generators similar to delta-connected loads (zero-order approximation).</p><p class="math-container">\[\begin{align}
&amp;\text{Initial line-neutral voltage: }   V_0 = V_{r0} +j V_{i0}\\
&amp;\text{Three-phase delta transformation matrix: }  M^\Delta = \begin{bmatrix}\;\;\;1 &amp; -1 &amp; \;\;0\\ \;\;\;0 &amp; \;\;\;1 &amp; -1\\ -1 &amp; \;\;\;0 &amp; \;\;\;1\end{bmatrix} \\
&amp;\text{Single-phase delta transformation matrix (triple nodes): }  M^\Delta = \begin{bmatrix}\;1 &amp; -1 \end{bmatrix} \\
&amp;\text{Initial line-line voltage: }  V_0^\Delta = M^\Delta V_0 \\
&amp;\text{Line-line current: }  (I^\Delta)^* = S^\Delta \oslash V_0^\Delta \\
&amp;\text{Line-neutral current: }  I_{bus} = (M^\Delta)^T I^\Delta \\
&amp;\text{Bus generation power: }  S_{bus} = V_0 \oslash I_{bus}^*
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L783-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_delta(pm::FOTPUPowerModel, nw::Int, id::Int, bus_id::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, qmin::Vector{&lt;:Real}, qmax::Vector{&lt;:Real}; report::Bool=true, bounded::Bool=true)</code></pre><p>Adds constraints for delta-connected generators similar to delta-connected loads (zero-order approximation).</p><p class="math-container">\[\begin{align}
&amp;\text{Initial line-neutral voltage: }   V_0 = V_{m0} \angle V_{a0}\\
&amp;\text{Three-phase delta transformation matrix: }  M^\Delta = \begin{bmatrix}\;\;\;1 &amp; -1 &amp; \;\;0\\ \;\;\;0 &amp; \;\;\;1 &amp; -1\\ -1 &amp; \;\;\;0 &amp; \;\;\;1\end{bmatrix} \\
&amp;\text{Single-phase delta transformation matrix (triple nodes): }  M^\Delta = \begin{bmatrix}\;1 &amp; -1 \end{bmatrix} \\
&amp;\text{Initial line-line voltage: }  V_0^\Delta = M^\Delta V_0 \\
&amp;\text{Line-line current: }  (I^\Delta)^* = S^\Delta \oslash V_0^\Delta \\
&amp;\text{Line-neutral current: }  I_{bus} = (M^\Delta)^T I^\Delta \\
&amp;\text{Line-neutral generation power: }  S_{bus} = V_0 \oslash I_{bus}^*
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L775-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_delta(pm::FOTRUPowerModel, nw::Int, id::Int, bus_id::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, qmin::Vector{&lt;:Real}, qmax::Vector{&lt;:Real}; report::Bool=true, bounded::Bool=true)</code></pre><p>Adds constraints for delta-connected generators similar to delta-connected loads (zero-order approximation).</p><p class="math-container">\[\begin{align}
&amp;\text{Initial line-neutral voltage: }   V_0 = V_{r0} +j V_{i0}\\
&amp;\text{Three-phase delta transformation matrix: }  M^\Delta = \begin{bmatrix}\;\;\;1 &amp; -1 &amp; \;\;0\\ \;\;\;0 &amp; \;\;\;1 &amp; -1\\ -1 &amp; \;\;\;0 &amp; \;\;\;1\end{bmatrix} \\
&amp;\text{Single-phase delta transformation matrix (triple nodes): }  M^\Delta = \begin{bmatrix}\;1 &amp; -1 \end{bmatrix} \\
&amp;\text{Initial line-line voltage: }  V_0^\Delta = M^\Delta V_0 \\
&amp;\text{Line-line current: }  (I^\Delta)^* = S^\Delta \oslash V_0^\Delta \\
&amp;\text{Line-neutral current: }  I_{bus} = (M^\Delta)^T I^\Delta \\
&amp;\text{Line-neutral generation power: }  S_{bus} = V_0 \oslash I_{bus}^*
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L693-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delta connected generator setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_delta(pm::LPUBFDiagModel, nw::Int, gen_id::Int, bus_id::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, qmin::Vector{&lt;:Real}, qmax::Vector{&lt;:Real}; report::Bool=true, bounded::Bool=true)</code></pre><p>Adds constraints for delta-connected generators similar to delta-connected loads (using auxilary variable X).</p><p class="math-container">\[\begin{align}
&amp;\text{Three-phase delta transformation matrix: }  T^\Delta = \begin{bmatrix}\;\;\;1 &amp; -1 &amp; \;\;0\\ \;\;\;0 &amp; \;\;\;1 &amp; -1\\ -1 &amp; \;\;\;0 &amp; \;\;\;1\end{bmatrix} \\
&amp;\text{Single-phase delta transformation matrix (triple nodes): }  T^\Delta = \begin{bmatrix}\;1 &amp; -1 \end{bmatrix} \\
&amp;\text{Line-neutral generation power: }  S_{bus} = diag(T^\Delta X_g) \\
&amp;\text{Line-line generation power: }  S^\Delta = diag(X_g T^\Delta)
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L477-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{SOCUBFModels, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{SOCUBFModels, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_delta(pm::SOCUBFModels, nw::Int, gen_id::Int, bus_id::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, qmin::Vector{&lt;:Real}, qmax::Vector{&lt;:Real}; report::Bool=true, bounded::Bool=true)</code></pre><p>Adds constraints for delta-connected generators similar to delta-connected loads (using auxilary variable X).</p><p class="math-container">\[\begin{align}
&amp;\text{Three-phase delta transformation matrix: }  T^\Delta = \begin{bmatrix}\;\;\;1 &amp; -1 &amp; \;\;0\\ \;\;\;0 &amp; \;\;\;1 &amp; -1\\ -1 &amp; \;\;\;0 &amp; \;\;\;1\end{bmatrix} \\
&amp;\text{Single-phase delta transformation matrix (triple nodes): }  T^\Delta = \begin{bmatrix}\;1 &amp; -1 \end{bmatrix} \\
&amp;\text{Line-neutral generation power: }  S_{bus} = diag(T^\Delta X_g) \\
&amp;\text{Line-line generation power: }  S^\Delta = diag(X_g T^\Delta)
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L266-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power_wye(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, links the terminal power flows <code>:pg_bus</code> and <code>:qg_bus</code> to the power variables <code>:pg</code> and <code>:qg</code> for wye-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L25-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power_wye(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates non-linear expressions for the generator power <code>:pd</code> and <code>:qd</code> of wye-connected generators as a function of voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L108-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_generator_power_wye(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, links the generator power variables <code>:pd</code> and <code>:qd</code> of wye-connected generators to the voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L225-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wye connected generator setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_current(
	pm::AbstractExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create non-linear expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L452-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_current(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L772-L783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_current_delta(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create non-linear expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> of delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L557-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_current_delta(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> for delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L821-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector, Vector}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector, Vector}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>We want to express s<em>ab = cp.|v</em>ab|+im.cq.|v<em>ab| i</em>ab = conj(s<em>ab/v</em>ab) = |v<em>ab|.(cq-im.cq)/conj(v</em>ab) = (1/|v<em>ab|).(cp-im.cq)*v</em>ab idem for i<em>bc and i</em>ca And then s<em>a = v</em>a.conj(i<em>a) = v</em>a.conj(i<em>ab-i</em>ca) idem for s<em>b and s</em>c</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L972-L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Vector, Vector}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Vector, Vector}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_current_delta(pm::FOTPUPowerModel, nw::Int, load_id::Int, load_bus_id::Int, cp::Vector, cq::Vector)</code></pre><p>No loads require a current variable. Delta loads are zero-order approximations and wye loads are first-order approximations around the initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_current_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_current_wye(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create non-linear expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> of wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L480-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_load_current_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_current_wye(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> for wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L799-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power(
	pm::AbstractExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, the load power does not require any constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L437-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, link the load power variables <code>:pd</code> and <code>:qd</code> to the voltage, and link together the power, voltage and current variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L621-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUBFModels, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUBFModels, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates the constraints modelling the (relaxed) voltage-dependent loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L793-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only support wye-connected, constant-power loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_power(pm::AbstractUnbalancedPowerModel, id::Int; nw::Int=nw_id_default, report::Bool=true)::Nothing</code></pre><p>Template function for load constraints.</p><p><strong>CONSTANT POWER</strong></p><p>Fixes the load power sd.</p><p class="math-container">\[sd = [sd_1, sd_2, sd_3]\]</p><p>What is actually fixed, depends on whether the load is connected in delta or wye. When connected in wye, the load power equals the per-phase power sn drawn at the bus to which the load is connected.</p><p class="math-container">\[sd_1 = v_a.conj(i_a) = sn_a\]</p><p><strong>CONSTANT CURRENT</strong></p><p>Sets the active and reactive load power sd to be proportional to the the voltage magnitude.</p><p class="math-container">\[pd = cp.|vm|
qd = cq.|vm|
sd = cp.|vm| + j.cq.|vm|\]</p><p><strong>CONSTANT IMPEDANCE</strong></p><p>Sets the active and reactive power drawn by the load to be proportional to the square of the voltage magnitude.</p><p class="math-container">\[pd = cp.|vm|^2
qd = cq.|vm|^2
sd = cp.|vm|^2 + j.cq.|vm|^2\]</p><p><strong>DELTA</strong></p><p>When connected in delta, the load power gives the reference in the delta reference frame. This means</p><p class="math-container">\[sd_1 = v_ab.conj(i_ab) = (v_a-v_b).conj(i_ab)\]</p><p>We can relate this to the per-phase power by</p><p class="math-container">\[sn_a = v_a.conj(i_a)
    = v_a.conj(i_ab-i_ca)
    = v_a.conj(conj(s_ab/v_ab) - conj(s_ca/v_ca))
    = v_a.(s_ab/(v_a-v_b) - s_ca/(v_c-v_a))\]</p><p>So for delta, sn is constrained indirectly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L738-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{FBSUBFPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{FBSUBFPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_power(pm::FBSUBFPowerModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load model is linearized around initial operating point. Wye loads are first-order and delta loads are zero-order approximations.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: }  v_{rd}^0 + j ⋅ v_{id}^0~\text{where}~{(v_m^0)}^2 = {(v_{rd}^0)}^2 + {(v_{id}^0)}^2\\
&amp;\text{Constant power: }  P^d = P^{d0},~Q^d = Q^{d0} \\
&amp;\text{Constant impedance: }  P^d = a ⋅ \left(2\cdot v_{rd} ⋅ v_{rd}^0+2 ⋅ v_{id}*v_{id}^0-{(v_{m}^0)}^2\right),\\
&amp;  Q^d = b ⋅ \left(2\cdot v_{rd} ⋅ v_{rd}^0+2 ⋅ v_{id}*v_{id}^0-{(v_{m}^0)}^2\right),  \\
&amp;\text{Constant current: }  P^d = a ⋅ \left(v_{m}^0 + \frac{v_{rd} ⋅ v_{rd}^0+ v_{id}*v_{id}^0-{(v_{m}^0)}^2}{v_{m}^0} \right),\\
&amp; Q^d = b ⋅ \left(v_{m}^0 + \frac{v_{rd} ⋅ v_{rd}^0+ v_{id}*v_{id}^0-{(v_{m}^0)}^2}{v_{m}^0} \right).
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L503-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTPUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTPUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_power(pm::FOTPUPowerModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load model is linearized around initial operating point. Wye loads are first-order and delta loads are zero-order approximations.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: }   v_{m0} \angle v_{a0}\\
&amp;\text{Constant power: }  P^d = P^{d0},~Q^d = Q^{d0} \\
&amp;\text{Constant impedance: }  P^d = a \cdot \left({v_{m0}}^2+2 \cdot v_{m0} \cdot (v_m-v_{m0})\right),\\
&amp;  Q^d = b \cdot \left({v_{m0}}^2+2 \cdot v_{m0} \cdot (v_m-v_{m0})\right),  \\
&amp;\text{Constant current: }  P^d = a \cdot v_m,\\
&amp; Q^d = b \cdot v_m.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L656-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTRUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTRUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_power(pm::FOTRUPowerModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load model is linearized around initial operating point similar to FBSUBFPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{LPUBFDiagModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{LPUBFDiagModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_power(pm::LPUBFDiagModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Delta/voltage-dependent load models for LPUBFDiagModel. Delta loads use the auxilary power variable (X). The constant current load model is derived by linearizing around the flat-start voltage solution.</p><p class="math-container">\[\begin{align}
&amp;\text{Constant power:} \Rightarrow P_i^d = P_i^{d0},~Q_i^d = Q_i^{d0} ~\forall i \in L \\
&amp;\text{Constant impedance (Wye):} \Rightarrow P_i^d = a_i \cdot w_i,~Q_i^d = b_i \cdot w_i ~\forall i \in L \\
&amp;\text{Constant impedance (Delta):} \Rightarrow P_i^d = 3\cdot a_i \cdot w_i,~Q_i^d = 3\cdot b_i \cdot w_i ~\forall i \in L \\
&amp;\text{Constant current (Wye):} \Rightarrow P_i^d = \frac{a_i}{2}\cdot \left( 1+w_i \right),~Q_i^d = \frac{b_i}{2}\cdot \left( 1+w_i \right) \forall i \in L \\
&amp;\text{Constant current (Delta):} \Rightarrow P_i^d = \frac{\sqrt{3} \cdot a_i}{2}\cdot \left( 1+w_i \right),~Q_i^d = \frac{\sqrt{3} \cdot b_i}{2}\cdot \left( 1+w_i \right) \forall i \in L
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L362-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{SDPUBFKCLMXModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{SDPUBFKCLMXModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates the constraints modelling the (relaxed) voltage-dependent loads for the matrix KCL formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L900-L903">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power(
	pm::ExplicitNeutralModels,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>Constrains load power variables for models with explicit neutrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L205-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power_delta(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, creates non-linear expressions for terminal power flows &#39;:pd<em>bus&#39; and &#39;:qd</em>bus&#39; of delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L232-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power_delta(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	model::LoadModel,
	a::Vector{&lt;:Real},
	b::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, link the load power variables <code>:pd</code> and <code>:qd</code> to the voltage, and link together the power, voltage and current variables for delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L712-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delta connected load setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power_wye(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, creates non-linear expressions for terminal power flows &#39;:pd<em>bus&#39; and &#39;:qd</em>bus&#39; of wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L165-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_load_power_wye(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	model::LoadModel,
	a::Vector{&lt;:Real},
	b::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, link the load power variables <code>:pd</code> and <code>:qd</code> to the voltage, and link together the power, voltage and current variables for wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L652-L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1076">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wye connected load setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractLPUBFModel, Int64, Vararg{Any, 5}}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractLPUBFModel, Int64, Vararg{Any, 5}}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractUBFModels}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractUBFModels}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_model_current(pm::AbstractUBFModels; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints for model current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L542-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{SDPUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{SDPUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_sdp.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCConicUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCConicUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCUBFModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCUBFModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedDCPModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedDCPModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_model_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, these models do not have complex voltage constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_model_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>do nothing by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsDistribution.constraint_mc_model_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_model_voltage(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for model voltage constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines voltage drop over a branch, linking from and to side voltage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_model_voltage_magnitude_difference(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints for modeling voltage magnitude difference across branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L520-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_model_voltage_magnitude_difference(pm::FBSUBFPowerModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, r::Matrix{&lt;:Real}, x::Matrix{&lt;:Real}, g_sh_fr::Matrix{&lt;:Real}, b_sh_fr::Matrix{&lt;:Real})</code></pre><p>Voltage drop over a branch linearized around initial operating point (forward sweep)</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating points: }  (v_{r0}^{fr} + j ⋅ v_{i0}^{fr}),~ (v_{r0}^{to} + j ⋅ v_{i0}^{to})\\
&amp;\text{Series active power flow: }  p_s^{fr} =  p^{fr} -  g_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2,\\
&amp;\text{Series reactive power flow: }  q_s^{fr} =  q^{fr} +  b_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2,\\
&amp;\text{Series real current flow: }  cr_s^{fr} =  \frac{(p_s^{fr} ⋅ v_{r0}^{fr} + q_s^{fr} ⋅ v_{i0}^{fr})}{{(v_{m0}^{fr})}^2},\\
&amp;\text{Series imaginary current flow: }  ci_s^{fr} =  \frac{(-q_s^{fr} ⋅ v_{r0}^{fr} + p_s^{fr} ⋅ v_{i0}^{fr})}{{(v_{m0}^{fr})}^2},\\
&amp;\text{Series real voltage drop: } v_{r}^{to} = v_{r}^{fr} - r ⋅ cr_s^{fr} + x ⋅ ci_s^{fr} ,\\
&amp;\text{Series imaginary voltage drop: } v_{i}^{to} = v_{i}^{fr} - x ⋅ cr_s^{fr} - r ⋅ ci_s^{fr}.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L203-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines voltage drop over a branch, linking from and to side voltage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Vararg{Any, 8}}" href="#PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Vararg{Any, 8}}"><code>PowerModelsDistribution.constraint_mc_network_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_network_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_network_power_balance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints that ensures that power generation and demand are balanced in OBF problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L418-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_ohms_yt_from(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	G::Matrix{&lt;:Real},
	B::Matrix{&lt;:Real},
	G_fr::Matrix{&lt;:Real},
	B_fr::Matrix{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, creates Ohms constraints for ACR models with explicit neutrals.</p><pre><code class="nohighlight hljs">s_fr = v_fr.*conj(Y*(v_fr-v_to))
s_fr = (vr_fr+im*vi_fr).*(G-im*B)*([vr_fr-vr_to]-im*[vi_fr-vi_to])
s_fr = (vr_fr+im*vi_fr).*([G*vr_fr-G*vr_to-B*vi_fr+B*vi_to]-im*[G*vi_fr-G*vi_to+B*vr_fr-B*vr_to])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L543-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="nohighlight hljs">p_fr ==     g[c,c] * vm_fr[c]^2 +
            sum( g[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) +
                 b[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c) +
            sum(-g[c,d]*vm_fr[c]*vm_to[d]*cos(va_fr[c]-va_to[d]) +
                -b[c,d]*vm_fr[c]*vm_to[d]*sin(va_fr[c]-va_to[d]) for d in conductor_ids(pm))
            + g_fr[c,c] * vm_fr[c]^2 +
            sum( g_fr[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) +
                 b_fr[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c)
            )
q_fr == -b[c,c] *vm_fr[c]^2 -
            sum( b[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) -
                 g[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c) -
            sum(-b[c,d]*vm_fr[c]*vm_to[d]*cos(va_fr[c]-va_to[d]) +
                 g[c,d]*vm_fr[c]*vm_to[d]*sin(va_fr[c]-va_to[d]) for d in conductor_ids(pm))
            -b_fr[c,c] *vm_fr[c]^2 -
            sum( b_fr[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) -
                 g_fr[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c)
            )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L638-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints</p><p>s<em>fr = v</em>fr.<em>conj(Y</em>(v<em>fr-v</em>to)) s<em>fr = (vr</em>fr+im<em>vi_fr).</em>(G-im<em>B)</em>([vr<em>fr-vr</em>to]-im<em>[vi<em>fr-vi</em>to]) s<em>fr = (vr</em>fr+im</em>vi<em>fr).<em>([G</em>vr</em>fr-G<em>vr_to-B</em>vi<em>fr+B*vi</em>to]-im<em>[G</em>vi<em>fr-G*vi</em>to+B<em>vr_fr-B</em>vr_to])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L726-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="nohighlight hljs">p[f_idx] == -b*(t[f_bus] - t[t_bus])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedNFAModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedNFAModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage angle variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ohms_yt_from(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for ohms constraint for branches on the from-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L464-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ohms_yt_from(pm::FOTPUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix{&lt;:Real}, B::Matrix{&lt;:Real}, G_fr::Matrix{&lt;:Real}, B_fr::Matrix{&lt;:Real})</code></pre><p>Ohm constraints similar to ACPUPowerModel. The nonlinear functions are approximated around initial operating points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L434-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ohms_yt_from(pm::FOTRUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix{&lt;:Real}, B::Matrix{&lt;:Real}, G_fr::Matrix{&lt;:Real}, B_fr::Matrix{&lt;:Real})</code></pre><p>Creates Ohms constraints by linearizing (similar to power balance constraints) around initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vararg{Matrix, 4}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vararg{Matrix, 4}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_ohms_yt_to(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	G::Matrix,
	B::Matrix,
	G_to::Matrix,
	B_to::Matrix
)</code></pre><p>For ACR models with explicit neutrals, creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form).</p><pre><code class="nohighlight hljs">p[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))
q[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L596-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="nohighlight hljs">p[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))
q[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L697-L704">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vararg{Matrix, 4}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vararg{Matrix, 4}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="nohighlight hljs">p[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))
q[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L760-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Do nothing, this model is symmetric</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ohms_yt_to(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for ohms constraint for branches on the to-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L492-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vararg{Any, 11}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vararg{Any, 11}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ohms_yt_to(pm::FOTPUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix{&lt;:Real}, B::Matrix{&lt;:Real}, G_to::Matrix{&lt;:Real}, B_to::Matrix{&lt;:Real})</code></pre><p>Ohm constraints similar to ACPUPowerModel. The nonlinear functions are approximated around initial operating points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L516-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vararg{Matrix, 4}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vararg{Matrix, 4}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_ohms_yt_to(pm::FOTRUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix, B::Matrix, G_to::Matrix, B_to::Matrix)</code></pre><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L434-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{NFAUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{NFAUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, this model is symmetric</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_oltc_tap_fix-Tuple{AbstractUnbalancedPowerModel, Int64, Vector, Vector}" href="#PowerModelsDistribution.constraint_mc_oltc_tap_fix-Tuple{AbstractUnbalancedPowerModel, Int64, Vector, Vector}"><code>PowerModelsDistribution.constraint_mc_oltc_tap_fix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For a variable tap transformer, fix the tap variables which are fixed. For example, an OLTC where the third phase is fixed, will have tap variables for all phases, but the third tap variable should be fixed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance(pm::AbstractUnbalancedActivePowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>power balanace constraint with line shunts and transformers, active power only</p><p class="math-container">\[p_{br} + p_{tr} + p_{sw} == p_{g} - p_{s} - p_{d} - G\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L101-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance(pm::FBSUBFPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints similar to ACRUPowerModel with shunt current calculated using initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTPUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTPUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance(pm::FOTPUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance equations similar to ACPUPowerModel. The nonlinear functions are approximated around initial operating point.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating points: }  v_{m0}^{t} \angle v_{a0}^t,~v_{m0}^u \angle v_{a0}^u\\
&amp; {v_m^t}^2 \Rightarrow {v_{m0}^t}^2+2 \cdot v_{m0}^t \cdot (v_m^t-v_{m0}^t)\\
&amp; v_m^t \cdot v_m^u \cdot \cos(v_a^t-v_a^u) \Rightarrow v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) +
\begin{bmatrix}
v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot \cos(v_{a0}^t-v_{a0}^u) \\
-v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u)
\end{bmatrix}^\top
\begin{bmatrix}
v_m^t-v_{m0}^t \\
v_m^u-v_{m0}^u \\
v_a^t-v_{a0}^t \\
v_a^u-v_{a0}^u
\end{bmatrix} \\
&amp; v_m^t \cdot v_m^u \cdot \sin(v_a^t-v_a^u) \Rightarrow v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) +
\begin{bmatrix}
v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
-v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u)
\end{bmatrix}^\top
\begin{bmatrix}
v_m^t-v_{m0}^t \\
v_m^u-v_{m0}^u \\
v_a^t-v_{a0}^t \\
v_a^u-v_{a0}^u
\end{bmatrix}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L61-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance(pm::FOTRUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints similar to ACRUPowerModel with shunt current linearized around initial operating point.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: }  (v_{r0} + j ⋅ v_{i0})\\
&amp; v_{r} ⋅ v_{i} = v_{r0} ⋅ v_{i0} + v_{r} ⋅ v_{i0} + v_{r0} ⋅ v_{i} - 2 ⋅ v_{r0} ⋅ v_{i0}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L106-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{SDPUBFKCLMXModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{SDPUBFKCLMXModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shunt handling in matrix form: I = Y.U S = U.I&#39; = U.(Y.U)&#39; = U.U&#39;.Y&#39; = W.Y&#39;   = (Wr+j.Wi)(G+jB)&#39; = (Wr+j.Wi)(G&#39;-j.B&#39;) = (Wr.G&#39;+Wi.B&#39;)+j(-Wr.B&#39;+Wi.G&#39;) P =  Wr.G&#39;+Wi.B&#39; Q = -Wr.B&#39;+Wi.G&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L1016-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_power_balance(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_gens::Vector{Tuple{Int,Vector{Int}}},
	bus_storage::Vector{Tuple{Int,Vector{Int}}},
	bus_loads::Vector{Tuple{Int,Vector{Int}}},
	bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>Imposes power balance constraints at each ungrounded terminal of bus <code>i</code> for rectangular voltage models with explicit neutrals. <code>sum(p + im*q) = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L160-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::AbstractUnbalancedACPModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control.</p><p class="math-container">\[\begin{align}
    &amp; Bs = z ⋅ bs, \\
    &amp;\text{capacitor ON: }  z = 1, \\
    &amp;\text{capacitor OFF: } z = 0.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L451-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::AbstractUnbalancedACRModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control.</p><p class="math-container">\[\begin{align}
    &amp; Bt = z ⋅ bs, \\
    &amp;\text{capacitor ON: }  z = 1, \\
    &amp;\text{capacitor OFF: } z = 0.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L504-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do in capc, no complex voltage variables in these models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for KCL constraints with capacitor control variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L350-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::FBSUBFPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control similar to ACRUPowerModel with shunt current calculated using initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FOTPUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FOTPUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::FOTPUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control with shunt current calculated using initial operating point.</p><p class="math-container">\[\begin{align}
    &amp; B_s = b_s ⋅ z,~~ cq_{sh} = B_s ⋅ v, \\
    &amp; B_s \cdot v_m^t \cdot v_m^u \cdot \cos(v_a^t-v_a^u) \Rightarrow B_{s0} \cdot v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) +
\begin{bmatrix}
B_{s0} \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
B_{s0} \cdot v_{m0}^t \cdot \cos(v_{a0}^t-v_{a0}^u) \\
-B_{s0} \cdot v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
B_{s0} \cdot v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u)
\end{bmatrix}^\top
\begin{bmatrix}
v_m^t-v_{m0}^t \\
v_m^u-v_{m0}^u \\
v_a^t-v_{a0}^t \\
v_a^u-v_{a0}^u \\
B_{s} -B_{s0}
\end{bmatrix} \\
&amp; B_s \cdot v_m^t \cdot v_m^u \cdot \sin(v_a^t-v_a^u) \Rightarrow B_{s0} \cdot v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) +
\begin{bmatrix}
 B_{s0} \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
 B_{s0} \cdot v_{m0}^t \cdot \sin(v_{a0}^t-v_{a0}^u) \\
 B_{s0} \cdot v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
 -B_{s0} \cdot v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
 v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u)
\end{bmatrix}^\top
\begin{bmatrix}
v_m^t-v_{m0}^t \\
v_m^u-v_{m0}^u \\
v_a^t-v_{a0}^t \\
v_a^u-v_{a0}^u \\
B_{s} -B_{s0}
\end{bmatrix}

\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L202-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::FOTRUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control with shunt current calculated using initial operating point.</p><p class="math-container">\[\begin{align}
    &amp; B_t = b_s ⋅ z,~~ cq_{sh} = B_t ⋅ v, \\
    &amp;\text{FOT approximation: }  B_t ⋅ v_r ⋅ v_i = B_{t0} ⋅ v_{r0} ⋅ v_{i0} + B_{t} ⋅ v_{r0} ⋅ v_{i0} + B_{t0} ⋅ v_{r} ⋅ v_{i0} + B_{t0} ⋅ v_{r0} ⋅ v_{i} - 3 ⋅ B_{t0} ⋅ v_{r0} ⋅ v_{i0}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L191-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_capc(pm::LPUBFDiagModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control linearized using McCormick envelopes</p><p class="math-container">\[\begin{align}
    &amp; B_s = b_s ⋅ z,~~ cq_{sh} = B_s ⋅ w, \\
    &amp;\text{Underestimator: }  cq_{sh} ≥ B_s ⋅ w_\text{min},~~ cq_{sh} ≥ b_s ⋅ w  + B_s ⋅ w_\text{max} - b_s ⋅ w_\text{max}\\
    &amp;\text{Overestimator: }   cq_{sh} ≤ B_s ⋅ w_\text{max},~~ cq_{sh} ≤ b_s ⋅ w  + B_s ⋅ w_\text{min} - b_s ⋅ w_\text{min}\\
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L174-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>power balance constraint with line shunts and transformers for load shed problem, DCP formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints for load shed problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>KCL for load shed problem with transformers (AbstractWForms)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed_simple-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed_simple-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><p>power balance constraint with line shunts and transformers for load shed problem, DCP formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_simple</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_simple</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_simple(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints for simple load shedding</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vararg{Vector{Tuple{Int64, Vector{Int64}}}, 4}}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_slack(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints which include a slack power at every bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}, Vector{&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines branch flow model power flow equations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_losses(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints for modeling power losses across branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L562-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_losses(pm::FBSUBFPowerModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, r::Matrix{&lt;:Real}, x::Matrix{&lt;:Real}, g_sh_fr::Matrix{&lt;:Real}, g_sh_to::Matrix{&lt;:Real}, b_sh_fr::Matrix{&lt;:Real}, b_sh_to::Matrix{&lt;:Real})</code></pre><p>Branch flow model power flow equation linearized around initial operating point (backward sweep)</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating points: }  (v_{r0}^{fr} + j ⋅ v_{i0}^{fr}),~ (v_{r0}^{to} + j ⋅ v_{i0}^{to})\\
&amp;\text{Voltage drop: }  v_{drop} = (v_{r0}^{fr} + j ⋅ v_{i0}^{fr}) - (v_{r0}^{to} + j ⋅ v_{i0}^{to}),\\
&amp;\text{Line series admittance: } y = (r+j ⋅ x)^{-1},\\
&amp;\text{Power loss: }  s_{loss} = v_{drop} ⋅ (y ⋅ v_{drop})^*,\\
&amp;\text{Active power flow: }  p^{fr} + p^{to} = g_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2 +  g_{sh}^{to} ⋅ {(v_{m0}^{to})}^2 + \Re(s_{loss}),\\
&amp;\text{Reactive power flow: }  q^{fr} + q^{to} = -b_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2 -  b_{sh}^{to} ⋅ {(v_{m0}^{to})}^2 + \Im(s_{loss}).
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L156-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines branch flow model power flow equations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_regen_setpoint_active-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any}" href="#PowerModelsDistribution.constraint_mc_regen_setpoint_active-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any}"><code>PowerModelsDistribution.constraint_mc_regen_setpoint_active</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>qq[i] == qq</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_storage_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1066">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsDistribution.constraint_mc_storage_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_current_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage current limit constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L959-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUBFAModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUBFAModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Neglects the active and reactive loss terms associated with the squared current magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUBFModels, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUBFModels, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Neglects the active and reactive loss terms associated with the squared current magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L1095">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only, lossless model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Vararg{Any, 6}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Vararg{Any, 6}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage loss constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L935-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedWConvexModels, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedWConvexModels, Int64, Int64, Int64, Vector{Int64}, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Any, Any}" href="#PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Any, Any}"><code>PowerModelsDistribution.constraint_mc_storage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Any, Any}" href="#PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Any, Any}"><code>PowerModelsDistribution.constraint_mc_storage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Tempate function for storage on/off constraints for MLD problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L971-L975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real}" href="#PowerModelsDistribution.constraint_mc_storage_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real}"><code>PowerModelsDistribution.constraint_mc_storage_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_power_setpoint_real(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, ps::Real)::Nothing</code></pre><p>Generic storage real power setpoint constraint</p><p class="math-container">\[P_s == P_s^{setpoint}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_power_setpoint_real(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage active power setpoint constraint, for power flow problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L876-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_thermal_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage thermal limit constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L948-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>constraint<em>mc</em>storage<em>thermal</em>limit(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, connections::Vector{Int}, rating::Real)</p><p>Linear version of storage thermal limit constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L556-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_ampacity(pm::AbstractUnbalancedACPModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on switches</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq vm_{fr}^2 i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1330-L1338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_ampacity(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch current limit constraint from-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1112-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_ampacity(pm::AbstractUnbalancedRectangularModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on switches</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq (vr_{fr}^2 + vi_{fr}^2) i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L1169-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_ampacity(pm::AbstractUnbalancedWModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on switches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq w_{fr} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L412-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{LPUBFDiagModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{LPUBFDiagModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_ampacity(pm::AbstractUnbalancedWModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})</code></pre><p>ACP current limit constraint on switches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq w_{fr} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L670-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_current-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_current(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crsw_bus</code> and <code>cisw_bus</code>, and link the from-side to the to-side switch current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1635-L1650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_current-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_current(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    report::Bool=true
)</code></pre><p>For models with explicit neutrals, link the switch currents or create appropiate expressions for them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L183-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_current_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the switch current magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side current, so it suffices to apply this only explicitly at the from-side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L784-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_current_limit(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the switch current magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side current, so it suffices to apply this only explicitly at the from-side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1667-L1680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_current_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch current limit constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_power-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_power(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int};
	report::Bool=true
)</code></pre><p>constraint<em>mc</em>switch<em>power(     pm::ReducedExplicitNeutralIVRModels,     nw::Int,     id::Int,     f</em>idx::Tuple{Int,Int,Int},     t<em>idx::Tuple{Int,Int,Int},     f</em>connections::Vector{Int},     t_connections::Vector{Int};     report::Bool=true )</p><p>For IVR models with explicit neutrals, create expressions for the terminal power flows <code>:psw_bus</code> and <code>qsw_bus</code>, and link the from-side to the to-side switch power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L741-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_power(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, link the switch power or create appropiate expressions for them</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L161-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_state-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_state(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch state constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/dcp.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_state_closed(pm::FBSUBFPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>Voltage constraints for closed switches similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L631-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_state_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, relax::Bool=false)::Nothing</code></pre><p>Template function for switch state on/off constraints (MLD problems)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_open</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_open</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_open</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_thermal_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the switch power magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side power when the switch is closed (equal voltages), and also when it is open since the power then equals zero on both ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L817-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractLPUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractLPUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_thermal_limit(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>This method is not yet implemented for AbstractLPUBFModel. If the limit is finite, a warning is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L523-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_thermal_limit(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the switch power magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side power when the switch is closed (equal voltages), and also when it is open since the power then equals zero on both ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1698-L1712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_switch_thermal_limit(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For quadratic IVR models with explicit neutrals, throw an error because this cannot be represented quadratically without introducing explicit power variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1735-L1747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_thermal_limit(pm::AbstractUnbalancedActivePowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, rating::Vector{&lt;:Real})::Nothing</code></pre><p>Active power only switch thermal limit constraint</p><p>math<code>-S_{max} \leq p_{fr} \leq S_{max}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L260-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_thermal_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch thermal limit constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_thermal_limit_from(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the from-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L663-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_thermal_limit_from(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the from-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1413-L1424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_thermal_limit_from(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For quadratic IVR models with explicit neutrals, throw an error because this cannot be represented quadratically without introducing explicit power variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1473-L1485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>-rate_a &lt;= p[f_idx] &lt;= rate_a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>p[f_idx]^2 + q[f_idx]^2 &lt;= rate_a^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_thermal_limit_from(pm::AbstractUnbalancedPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, rate_a::Vector{&lt;:Real})::Nothing</code></pre><p>Generic thermal limit constraint for branches (from-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_thermal_limit_from(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for branch thermal constraints (from-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L602-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_thermal_limit_to(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	t_idx::Tuple{Int,Int,Int},
	t_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the from-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L689-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_thermal_limit_to(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	t_idx::Tuple{Int,Int,Int},
	t_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the to-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1442-L1453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_thermal_limit_to(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	t_idx::Tuple{Int,Int,Int},
	t_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For quadratic IVR models with explicit neutrals, throw an error because this cannot be represented quadratically without introducing explicit power variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1495-L1507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>p[t_idx]^2 + q[t_idx]^2 &lt;= rate_a^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_thermal_limit_to(pm::AbstractUnbalancedPowerModel, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, rate_a::Vector{&lt;:Real})::Nothing</code></pre><p>Generic thermal limit constraint for branches (to-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_thermal_limit_to(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for branch thermal constraints (to-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L622-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates phase angle constraints at reference buses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedNFAModel, Int64}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedNFAModel, Int64}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage angle variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPolarModels, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPolarModels, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates phase angle constraints at reference buses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_theta_ref(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for reference angle constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>do nothing, no way to represent this in these variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_theta_ref(pm::FBSUBFPowerModel, nw::Int, i::Int, va_ref::Vector{&lt;:Real})</code></pre><p>Creates phase angle constraints at reference buses similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{LPUBFDiagModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{LPUBFDiagModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>balanced three-phase phasor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{&lt;:Real}, Vector{Int64}, Vector{Bool}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{&lt;:Real}, Vector{Int64}, Vector{Bool}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_theta_ref(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	va::Vector{&lt;:Real},
	terminals::Vector{Int},
	grounded::Vector{Bool}
)</code></pre><p>Creates phase angle constraints at bus <code>i</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L355-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_current(
	pm::AbstractExplicitNeutralIVRModel,
	i::Int;
	nw::Int=nw_id_default,
	fix_taps::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, links the current variables of the from-side and to-side transformer windings, and creates expressions for the terminal current flows</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L908-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_current_dy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_current_dy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_current_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_current_dy(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For IVR models with explicit neutrals, links the current variables of the from-side and to-side transformer windings, and creates expressions for the terminal current flows for delta-wye connected transformers</p><pre><code class="nohighlight hljs">scale*cr_fr_P + cr_to_P == 0
scale*ci_fr_P + ci_to_P == 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L999-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_current_yy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_current_yy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_current_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_current_yy(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For IVR models with explicit neutrals, links the current variables of the from-side and to-side transformer windings, and creates expressions for the terminal current flows for wye-wye connected transformers</p><pre><code class="nohighlight hljs">scale*cr_fr_P + cr_to_P == 0
scale*ci_fr_P + ci_to_P == 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L952-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_power-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=true)::Nothing</code></pre><p>Template function for Transformer constraints in Power-voltage space, considering winding type, conductor order, polarity and tap settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L702-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power-Tuple{NFAUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_power-Tuple{NFAUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power(pm::NFAUPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>transformer active power only constraint pf=-pt</p><p class="math-container">\[p_f[fc] == -pt[tc]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L186-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_power_dy(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For ACR models with explicit neutrals, links the from-side and to-side power variables of delta-wye connected transformers. Expressions for the terminal power flow variables are also added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L399-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L765">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds all constraints required to model a two-winding, delta-wye connected transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delta-wye transformer power constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_dy(pm::FBSUBFPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, delta-wye connected transformer similar to ACRUPowerModel with power constraints using initial operating point voltage instead of actual voltage variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L726-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_dy(pm::FOTPUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, delta-wye connected transformer similar to ACPUPowerModel with voltage constraints linearized using first-order Taylor approximation and power constraints simplified using initial operating point voltage instead of actual voltage variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L586-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_dy(pm::FOTRUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, delta-wye connected transformer similar to ACRUPowerModel with power constraints using initial operating point voltage instead of actual voltage variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L636-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{SOCUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{SOCUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_dy(pm::SOCUBFModels, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Constraints to model a two-winding, delta-wye connected transformer.</p><p class="math-container">\[\begin{align}
    &amp;{W}_{fr}^{ij}-{W}_{fr}^{ik}-{W}_{fr}^{lj}+{W}_{fr}^{lk} = t_m^2{W}_{to}^{ij} ~\forall i,j \in \{1,2,3\}~ \text{and}~ k,l \in \{2,3,1\}   \\
    &amp;{S}_{fr} = X_tT_t \\
    &amp;{S}_{fr}^\Delta = T_tX_t \\
    &amp; {s}_{fr}^\Delta + {s}_{to} = 0\\
    &amp; {M}_{\Delta} =
    \begin{bmatrix}
    {W}_{fr} &amp; {X}_{t} \\
     {X}_{t}^{\text{H}} &amp;  {L}_{\Delta}
    \end{bmatrix} \succeq 0
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L209-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_power_yy(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For ACR models with explicit neutrals, links the from-side and to-side power variables of wye-wye connected transformers. Expressions for the terminal power flow variables are also added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L312-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds all constraints required to model a two-winding, wye-wye connected transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wye-wye transformer power constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy(pm::FBSUBFPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, wye-wye connected transformer similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L650-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy(pm::FOTPUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, wye-wye connected transformer similar to ACPUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotp.jl#L527-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy(pm::FOTRUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, wye-wye connected transformer similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L560-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Links to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true</p><p class="math-container">\[w_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{SOCUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{SOCUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy(pm::SOCUBFModels, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Constraints to model a two-winding, wye-wye connected transformer.</p><p class="math-container">\[\begin{align}
    &amp; {W}_{fr} = {T}_{m}{T}_{m}^{H} {W}_{to}  \\
    &amp; {s}_{fr} + {s}_{to} = 0
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L139-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector, Vector, ConnConfig, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector, Vector, ConnConfig, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_thermal_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple,
	t_idx::Tuple,
	f_bus::Int,
	t_bus::Int,
	f_connections::Vector,
	t_connections::Vector,
	config::ConnConfig,
	sm_ub::Real;
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the magnitude of the total apparent power at each winding of the transformer.</p><pre><code class="nohighlight hljs">sum(pt_fr)^2 + sum(qt_fr)^2 &lt;= sm_ub^2
sum(pt_to)^2 + sum(qt_to)^2 &lt;= sm_ub^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_acr.jl#L480-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector, Vector, ConnConfig, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector, Vector, ConnConfig, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_thermal_limit(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple,
	t_idx::Tuple,
	f_bus::Int,
	t_bus::Int,
	f_connections::Vector,
	t_connections::Vector,
	config::ConnConfig,
	sm_ub::Real;
	report::Bool=true
)</code></pre><p>For non-linear IVR models with explicit neutrals, imposes a bound on the magnitude of the total apparent power at both windings. Expressions are created for the transformer power variables.</p><pre><code class="nohighlight hljs">sum(pt_fr)^2 + sum(qt_fr)^2 &lt;= sm_ub^2
sum(pt_to)^2 + sum(qt_to)^2 &lt;= sm_ub^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1049-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector, Vector, ConnConfig, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector, Vector, ConnConfig, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_thermal_limit(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple,
	t_idx::Tuple,
	f_bus::Int,
	t_bus::Int,
	f_connections::Vector,
	t_connections::Vector,
	config::ConnConfig,
	sm_ub::Real;
	report::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, imposes a bound on the magnitude of the total apparent power at both windings.</p><pre><code class="nohighlight hljs">sum(pt_fr)^2 + sum(qt_fr)^2 &lt;= sm_ub^2
sum(pt_to)^2 + sum(qt_to)^2 &lt;= sm_ub^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_ivr.jl#L1127-L1150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_thermal_limit(
	pm::ExplicitNeutralModels,
	id::Int;
	nw::Int=nw_id_default,
	bounded::Bool=true,
	report::Bool=true,
)</code></pre><p>Imposes a bound on the total apparent at each transformer winding</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L135-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_voltage-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_voltage-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_voltage(
    pm::ExplicitNeutralModels,
    i::Int;
    nw::Int=nw_id_default,
    fix_taps::Bool=true
)</code></pre><p>For models with explicit neutrals, links the voltage of the from-side and to-side transformer windings</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L96-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_voltage_dy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_voltage_dy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_voltage_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_voltage_dy(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For rectangular voltage models with explicit neutrals, links the voltage of the from-side and to-side transformer windings for delta-wye connected transformers</p><pre><code class="nohighlight hljs">Md*vr_fr_P == scale * (vr_to_P - vr_to_n)
Md*vi_fr_P == scale * (vi_to_P - vi_to_n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L722-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_voltage_yy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_voltage_yy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_voltage_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_transformer_voltage_yy(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For rectangular voltage models with explicit neutrals, links the voltage of the from-side and to-side transformer windings for wye-wye connected transformers</p><pre><code class="nohighlight hljs">(vr_fr_P-vr_fr_n) == scale * (vr_to_P.-vr_to_n)
(vi_fr_P-vi_fr_n) == scale * (vi_to_P.-vi_to_n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L677-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_absolute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_absolute(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	vmin::Vector{&lt;:Real},
	vmax::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>Imposes absolute voltage magnitude bounds for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L243-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_absolute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_absolute(
    pm::RectangularVoltageExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    bounded::Bool=true,
    report::Bool=true,
)</code></pre><p>Imposes absolute voltage magnitude bounds for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is duplicated at PowerModelsDistribution level to correctly handle the indexing of the shunts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any, Any}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any, Any}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bounds the voltage angle difference between bus pairs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/ivr.jl#L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedNFAModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedNFAModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, these models do not have angle difference constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPolarModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPolarModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_angle_difference(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints of the voltage angle difference across branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L586-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FBSUBFPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FBSUBFPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_angle_difference(pm::FBSUBFPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, angmin::Vector{&lt;:Real}, angmax::Vector{&lt;:Real})</code></pre><p>Nothing to do, this model ignores angle difference constraints&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FOTRUPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FOTRUPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_angle_difference(pm::FOTRUPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, angmin::Vector{&lt;:Real}, angmax::Vector{&lt;:Real})</code></pre><p>Nothing to do, this model ignores angle difference constraints&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{Int64}, Vector{Bool}}" href="#PowerModelsDistribution.constraint_mc_voltage_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{Int64}, Vector{Bool}}"><code>PowerModelsDistribution.constraint_mc_voltage_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_fixed(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	vm::Vector{&lt;:Real},
	va::Vector{&lt;:Real},
	terminals::Vector{Int},
	grounded::Vector{Bool}
)</code></pre><p>Fixes the voltage variables at bus <code>i</code> to <code>vm.*exp.(im*va)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L307-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vmin &lt;= vm[i] &lt;= vmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_magnitude_bounds(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for voltage magnitude bounds constraints.</p><p>This constraint captures problem agnostic constraints that define limits for voltage magnitudes (where variable bounds cannot be used). Notable examples include IVRUPowerModel and ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_magnitude_bounds(pm::FBSUBFPowerModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>Upper voltage magnitude limits are linearized using outer approximation. Lower voltage magnitude limits are linearized around initial operating point.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: } ⇒ v_{r}^0 + j ⋅ v_{i}^0~\text{where}~{(v_m^0)}^2 = {(v_{r}^0)}^2 + {(v_{i}^0)}^2\\
&amp;\text{Lower limits: }  2 ⋅ v_{r} ⋅ v_{r}^0 + 2 ⋅ v_{i} ⋅ v_{i}^0 - {(v_{m}^0)}^2 ≥ v_{min}^2,\\
&amp;\text{Upper limits: } -v_{max} ≤  v_{r} ≤ v_{max},\\
&amp; -v_{max} ≤  v_{i} ≤ v_{max},\\
&amp;-\sqrt{2} ⋅ v_{max} ≤  v_{r} + v_{i} ≤ \sqrt{2} ⋅ v_{max},\\
&amp; -\sqrt{2} ⋅ v_{max} ≤  v_{r} - v_{i} ≤ \sqrt{2} ⋅ v_{max}.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_fbs.jl#L98-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FOTRUPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FOTRUPowerModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_magnitude_bounds(pm::FOTRUPowerModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>Linearized voltage magnitude limits similar to FBSUBFPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/fotr.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{&lt;:Real}, Vector{Int64}, Vector{Bool}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{&lt;:Real}, Vector{Int64}, Vector{Bool}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_magnitude_fixed(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	vm::Vector{&lt;:Real},
	va::Vector{&lt;:Real},
	terminals::Vector{Int},
	grounded::Vector{Bool}
)</code></pre><p>Fixes the voltage variables at bus <code>i</code> to <code>vm.*exp.(im*va)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L331-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vm[i] == vmref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acp.jl#L1053">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vm[i] == vmref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/acr.jl#L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/apo.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_voltage_magnitude_only(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for voltage magnitude setpoint constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vm[i] == vmref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/shared.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{&lt;:Tuple{Any, Any, Real}}, Vector{&lt;:Tuple{Any, Any, Real}}}" href="#PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{&lt;:Tuple{Any, Any, Real}}, Vector{&lt;:Tuple{Any, Any, Real}}}"><code>PowerModelsDistribution.constraint_mc_voltage_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_pairwise(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	vm_pair_lb::Vector,
	vm_pair_ub::Vector;
	report::Bool=true
)</code></pre><p>Imposes pairwise voltage magnitude bounds, i.e. magnitude bounds on the voltage between to terminals, for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/en_shared.jl#L275-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_pairwise(
    pm::RectangularVoltageExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    bounded::Bool=true,
    report::Bool=true,
)</code></pre><p>Imposes pairwise voltage magnitude bounds, i.e. magnitude bounds on the voltage between to terminals, for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SDPUBFModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SDPUBFModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add explicit PSD-ness of W for nodes where it is not implied</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_sdp.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCConicUBFModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCConicUBFModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add explicit PSD-ness of W for nodes where it is not implied</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCUBFModels, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCUBFModels, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add explicit PSD-ness of W for nodes where it is not implied</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_soc.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_reference-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_reference-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function constraint_mc_voltage_reference(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    bounded::Bool=true,
    report::Bool=true,
)</code></pre><p>Imposes suitable constraints for the voltage at the reference bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template_en.jl#L40-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_pqw-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, Vararg{Real, 6}}" href="#PowerModelsDistribution.constraint_pqw-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, Vararg{Real, 6}}"><code>PowerModelsDistribution.constraint_pqw</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates the constraints modelling the (relaxed) voltage-dependency of the power consumed in each phase, s=p+jq. This is completely symmetrical for p and q, with appropriate substitutions of the variables and parameters: p-&gt;q, a-&gt;b, alpha-&gt;beta, pmin-&gt;qmin, pmax-&gt;qmax</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx.jl#L730-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}" href="#PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}"><code>PowerModelsDistribution.constraint_storage_complementarity_mi</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_mi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for mixed-integer storage complementarity constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1057-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_nl</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_nl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_nl(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for nonlinear storage complementarity constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1046-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{LPUBFDiagModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{LPUBFDiagModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_nl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_nl(pm::LPUBFDiagModel, n::Int, i::Int)</code></pre><p>Linear version of storage complementarity constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/form/bf_mx_lin.jl#L540-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Real, Real, Real}" href="#PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Real, Real, Real}"><code>PowerModelsDistribution.constraint_storage_state</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64}" href="#PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64}"><code>PowerModelsDistribution.constraint_storage_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_state(pm::AbstractUnbalancedPowerModel, i::Int, nw_1::Int, nw_2::Int)::Nothing</code></pre><p>Template function for storage state constraints for multinetwork problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1020-L1024">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_storage_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_state(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage state constraints (non multinetwork)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint_template.jl#L1000-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state_initial-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vararg{Real, 4}}" href="#PowerModelsDistribution.constraint_storage_state_initial-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vararg{Real, 4}}"><code>PowerModelsDistribution.constraint_storage_state_initial</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}" href="#PowerModelsDistribution.constraint_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{&lt;:Real}}"><code>PowerModelsDistribution.constraint_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_switch_thermal_limit(pm::AbstractUnbalancedPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, rating::Vector{&lt;:Real})::Nothing</code></pre><p>Generic thermal limit constraint for switches (from-side)</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq S_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/constraint.jl#L198-L206">source</a></section></article><h2 id="Relaxation-Helpers"><a class="docs-heading-anchor" href="#Relaxation-Helpers">Relaxation Helpers</a><a id="Relaxation-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxation-Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.cut_complex_product_and_angle_difference-NTuple{7, Any}" href="#PowerModelsDistribution.cut_complex_product_and_angle_difference-NTuple{7, Any}"><code>PowerModelsDistribution.cut_complex_product_and_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cut_complex_product_and_angle_difference(m, wf, wt, wr, wi, angmin, angmax)</code></pre><p>A valid inequality for the product of two complex variables with magnitude and angle difference bounds. In the literature this constraints are called the Lifted Nonlinear Cuts (LNCs). @misc{1512.04644,     Author = {Carleton Coffrin and Hassan Hijazi and Pascal Van Hentenryck},     Title = {Strengthening the SDP Relaxation of AC Power Flows with Convex         Envelopes, Bound Tightening, and Lifted Nonlinear Cuts},     Year = {2015},     Eprint = {arXiv:1512.04644}, }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L195-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_psd_real-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_psd_real-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_psd_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_psd_real(m, mxreal, mximag; ndim=3)</code></pre><p>For debugging / exploration: real-valued SDP to SDP relaxation based on PSDness of principal minors, default is 3x3 SDP relaxation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc-Tuple{JuMP.Model, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc-Tuple{JuMP.Model, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_soc(m::JuMP.Model, mxreal, mximag; complex::Bool=true)</code></pre><p>See section 4.3 for complex to real PSD constraint transformation: @article{Fazel2001, author = {Fazel, M. and Hindi, H. and Boyd, S.P.}, title = {{A rank minimization heuristic with application to minimum order system approximation}}, doi = {10.1109/ACC.2001.945730}, journal = {Proc. American Control Conf.}, number = {2}, pages = {4734–4739}, url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=945730}, volume = {6}, year = {2001} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L113-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_complex-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_complex-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_complex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_soc_complex(m, mxreal, mximag)</code></pre><p>SDP to SOC relaxation of type 2, applied to complex-value matrix,  as described in:</p><pre><code class="nohighlight hljs">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_complex_conic-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_complex_conic-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_complex_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_soc_complex_conic(m, mxreal, mximag)</code></pre><p>SDP to SOC relaxation of type 2, applied to complex-value matrix,  as described in:</p><pre><code class="nohighlight hljs">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_conic-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_conic-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_soc_conic(m, mxreal, mximag; complex=true)</code></pre><p>See section 4.3 for complex to real PSD constraint transformation: @article{Fazel2001, author = {Fazel, M. and Hindi, H. and Boyd, S.P.}, title = {{A rank minimization heuristic with application to minimum order system approximation}}, doi = {10.1109/ACC.2001.945730}, journal = {Proc. American Control Conf.}, number = {2}, pages = {4734–4739}, url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=945730}, volume = {6}, year = {2001} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L145-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_real-Tuple{Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_real-Tuple{Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_soc_real(m, mx)</code></pre><p>SDP to SOC relaxation of type 2, applied to real-value matrix,  as described in:</p><pre><code class="nohighlight hljs">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_real_conic-Tuple{Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_real_conic-Tuple{Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_real_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_psd_to_soc_real_conic(m, mx)</code></pre><p>SDP to SOC relaxation of type 2, applied to real-value matrix,  as described in:</p><pre><code class="nohighlight hljs">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/relaxation_scheme.jl#L57-L73">source</a></section></article><h2 id="Miscellaneous-Helpers"><a class="docs-heading-anchor" href="#Miscellaneous-Helpers">Miscellaneous Helpers</a><a id="Miscellaneous-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calculate_tm_scale" href="#PowerModelsDistribution.calculate_tm_scale"><code>PowerModelsDistribution.calculate_tm_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the tap scale factor for the non-dimensionalized equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/data.jl#L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calc_branch_y" href="#PowerModelsDistribution.calc_branch_y"><code>PowerModelsDistribution.calc_branch_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_branch_y(branch::Dict{String,&lt;:Any})</code></pre><p>computes branch admittance matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/data.jl#L961-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calc_buspair_parameters" href="#PowerModelsDistribution.calc_buspair_parameters"><code>PowerModelsDistribution.calc_buspair_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_buspair_parameters(buses, branches)</code></pre><p>Computes the buspair parameters for the network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/5dac0a8fad1810121742c89ea1c4f8a2a0d0fa3b/src/core/ref.jl#L45-L49">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="variables.html">« Variables</a><a class="docs-footer-nextpage" href="objectives.html">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 26 May 2023 18:16">Friday 26 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
