<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow Computations · PowerModelsDistribution</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="PowerModelsDistribution logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PowerModelsDistribution</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../installation.html">Installation Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="quickguide.html">Getting Started</a></li><li><a class="tocitem" href="external-data-formats.html">External Data Formats</a></li><li><a class="tocitem" href="eng-data-model.html">Engineering Data Model</a></li><li><a class="tocitem" href="enums.html">Enums in Engineering Model</a></li><li><a class="tocitem" href="math-model.html">Mathematical Model</a></li><li><a class="tocitem" href="eng2math.html">Conversion to Mathematical Model</a></li><li><a class="tocitem" href="formulations.html">Unbalanced Formulations</a></li><li><a class="tocitem" href="specifications.html">Problem Specifications</a></li><li><a class="tocitem" href="load-model.html">Load Models</a></li><li><a class="tocitem" href="connections.html">Connecting Components</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/Beginners Guide.html">Beginners Guide</a></li><li><a class="tocitem" href="../tutorials/The Engineering Model.html">The Engineering Data Model</a></li><li><a class="tocitem" href="../tutorials/Engineering Model - Helper Functions.html">Engineering Model: Helper Functions</a></li><li><a class="tocitem" href="../tutorials/basic.html">Basics</a></li><li><a class="tocitem" href="../tutorials/Extension Tutorial.html">Extending PowerModelsDistribution</a></li><li><a class="tocitem" href="../tutorials/Explicit Neutral Models.html">Explicit Neutral Models</a></li><li><a class="tocitem" href="../tutorials/Native Power Flow.html">Native Power Flow Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reference/base.html">Base</a></li><li><a class="tocitem" href="../reference/logging.html">Logging</a></li><li><a class="tocitem" href="../reference/data_models.html">Data Models</a></li><li><a class="tocitem" href="../reference/enums.html">Enums</a></li><li><a class="tocitem" href="../reference/formulations.html">Formulations</a></li><li><a class="tocitem" href="../reference/problems.html">Problems</a></li><li><a class="tocitem" href="../reference/variables.html">Variables</a></li><li><a class="tocitem" href="../reference/constraints.html">Constraints</a></li><li><a class="tocitem" href="../reference/objectives.html">Objectives</a></li><li><a class="tocitem" href="../reference/constants.html">Constants</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../developer/extensions.html">Extensions</a></li><li><a class="tocitem" href="../developer/contributing.html">Contributing</a></li><li><a class="tocitem" href="../developer/style.html">Style Guide</a></li><li><a class="tocitem" href="../developer/roadmap.html">Roadmap</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="power-flow.html">Power Flow Computations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="power-flow.html">Power Flow Computations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/main/docs/src/manual/power-flow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Power-Flow-Computations"><a class="docs-heading-anchor" href="#Power-Flow-Computations">Power Flow Computations</a><a id="Power-Flow-Computations-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Computations" title="Permalink"></a></h1><p>The typical goal of PowerModelsDistribution is to build a JuMP model that is used to solve ditribution power network optimization problems. The JuMP model abstraction enables PowerModelsDistribution to have state-of-the-art performance on a wide range of problem formulations. That said, for the specific case of power flow computations, in some specific applications performance gains can be had by avoiding the JuMP model abstraction and solving the problem more directly. To that end, PowerModelsDistribution includes Julia-native solvers for AC power flow in rectangular voltage coordinates. This section provides an overview of the different power flow options that are available in PowerModelsDistribution and under what circumstances they may be beneficial.</p><h2 id="Generic-Power-Flow"><a class="docs-heading-anchor" href="#Generic-Power-Flow">Generic Power Flow</a><a id="Generic-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Power-Flow" title="Permalink"></a></h2><p>The general purpose power flow solver in PowerModelsDistribution is,</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.solve_mc_pf" href="#PowerModelsDistribution.solve_mc_pf"><code>PowerModelsDistribution.solve_mc_pf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Power Flow Problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/a181da565ab1f259e687a996abc9c23aa32aaac5/src/prob/pf.jl#L1">source</a></section></article><p>This function builds a JuMP model for a wide variety of unbalanced power flow formulations supported by PowerModelsDistribution. For example it supports,</p><ul><li><code>ACPUPowerModel</code> - a non-convex nonlinear AC unbalanced power flow using complex voltages in polar coordinates</li><li><code>ACRPowerModel</code> - a non-convex nonlinear AC unbalanced power flow using complex voltages in rectangular coordinates</li><li><code>ACRENPowerModel</code> - a non-convex nonlinear AC unbalanced power flow using complex voltages in rectangular coordinates with explicit neutral conductor</li><li><code>IVRUPowerModel</code> - a non-convex nonlinear AC power unbalanced flow using current voltage variables in rectangular coordinates</li><li><code>IVRENPowerModel</code> - a non-convex nonlinear AC unbalanced power flow using current voltage variables in rectangular coordinates with explicit neutral conductor</li></ul><p>The <code>solve_mc_pf</code> solution method is both formulation and solver agnostic and can leverage the wide range of solvers that are available in the JuMP ecosystem. Many of these solvers are commercial-grade, which in turn makes <code>solve_mc_pf</code> the most reliable power flow solution method in PowerModelsDistribution.</p><h3 id="Warm-Starting"><a class="docs-heading-anchor" href="#Warm-Starting">Warm Starting</a><a id="Warm-Starting-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Starting" title="Permalink"></a></h3><p>In some applications an initial guess of the power flow solution may be available. In such a case, this information may be able to decrease a solver&#39;s time to convergence, especially when solving systems of nonlinear equations. The <code>_start</code> postfix can be used in the network data to initialize the solver&#39;s variables and provide a suitable solution guess. The most common values are as follows,</p><p>For each generator,</p><ul><li><code>pg_start</code> - active power injection starting point</li><li><code>qg_start</code> - reactive power injection starting point</li></ul><p>For each bus,</p><ul><li><code>vm_start</code> - voltage magnitude starting point for the <code>ACPUPowerModel</code> model</li><li><code>va_start</code> - voltage angle starting point for the <code>ACPUPowerModel</code> model</li><li><code>vr_start</code> - real voltage starting point for the <code>IVRUPowerModel</code> model</li><li><code>vi_start</code> - imaginary voltage starting point for the <code>IVRUPowerModel</code> model</li></ul><p>The following helper function can be used to use the solution point in the network data as the starting point for <code>solve_mc_pf</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.add_start_voltage!" href="#PowerModelsDistribution.add_start_voltage!"><code>PowerModelsDistribution.add_start_voltage!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_start_voltage!(
    data_math::Dict{String,Any};
    coordinates=:rectangular,
    uniform_v_start=missing,
    vr_default=0.0,
    vi_default=0.0,
    vm_default=0.0,
    va_default=0.0,
    epsilon::Number=1E-3,
)::Dict{String,Any}</code></pre><p>Adds start values for the voltage to the buses. For a multinetwork data model, you can calculate the start voltages for a representative network through &#39;calc<em>start</em>voltage&#39;, and pass the result as &#39;uniform<em>v</em>start&#39; to use the same values for all networks and avoid recalculating it for each network. The argument &#39;epsilon&#39; controls the offset added to ungrounded terminals which would otherwise be set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/a181da565ab1f259e687a996abc9c23aa32aaac5/src/data_model/transformations/initialization.jl#L202-L218">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"></div></div><p>Warm starting a solver is a very delicate task and can easily result in degraded performance. Using PowerModelsDistribution&#39; default flat-start values is recommended before experimenting with warm starting a solver.</p><h2 id="Native-Power-Flow"><a class="docs-heading-anchor" href="#Native-Power-Flow">Native Power Flow</a><a id="Native-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Native-Power-Flow" title="Permalink"></a></h2><p>The AC Unbalanced Power Flow problem is ubiquitous in power system analysis. The problem requires solving a system of nonlinear equations, usually via a Newton-Raphson type of algorithm. In PowerModelsDistribution, the standard Julia library is used for solving this system of nonlinear equations. The following function is used to solve Unbalanced Power Flow problem with voltages in rectangular coordinates.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.compute_mc_pf" href="#PowerModelsDistribution.compute_mc_pf"><code>PowerModelsDistribution.compute_mc_pf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_mc_pf(
    data::Dict{String,&lt;:Any};
    explicit_neutral::Bool=false,
    max_iter::Int=100,
    v_start::Union{Dict{&lt;:Any,&lt;:Any},Missing}=missing,
    stat_tol::Real=1e-8,
    verbose::Bool=false,
    kron_reduce::Bool=true,
    phase_project::Bool=false,
    multinetwork::Bool=false,
    global_keys::Set{String}=Set{String}(),
    eng2math_extensions::Vector{&lt;:Function}=Function[],
    eng2math_passthrough::Dict{String,&lt;:Vector{&lt;:String}}=Dict{String,Vector{String}}(),
    make_pu_extensions::Vector{&lt;:Function}=Function[],
    map_math2eng_extensions::Dict{String,&lt;:Function}=Dict{String,Function}(),
    make_si::Bool=!get(data, &quot;per_unit&quot;, false),
    make_si_extensions::Vector{&lt;:Function}=Function[],
    dimensionalize_math_extensions::Dict{String,Dict{String,Vector{String}}}=Dict{String,Dict{String,Vector{String}}}(),
)::Dict{String,Any}</code></pre><p>Takes data in either the ENGINEERING or MATHEMATICAL model, a model type (<em>e.g.</em>, <a href="../reference/formulations.html#PowerModelsDistribution.ACRUPowerModel"><code>ACRUPowerModel</code></a>), and model builder function (<em>e.g.</em>, <a href="../reference/problems.html#PowerModelsDistribution.build_mc_opf-Tuple{AbstractExplicitNeutralACRModel}"><code>build_mc_opf</code></a>), and returns a solution in the original data model defined by <code>data</code>.</p><p>If <code>make_si</code> is false, data will remain in per-unit.</p><p>For an explanation of <code>multinetwork</code> and <code>global_keys</code>, see <a href="../reference/data_models.html#PowerModelsDistribution.make_multinetwork-Tuple{Dict{String}}"><code>make_multinetwork</code></a></p><p>For an explanation of <code>eng2math_extensions</code> and <code>eng2math_passthrough</code>, see <a href="../reference/data_models.html#PowerModelsDistribution.transform_data_model"><code>transform_data_model</code></a></p><p>For an explanation of <code>make_pu_extensions</code>, see <a href="../reference/data_models.html#PowerModelsDistribution.make_per_unit!-Tuple{Dict{String}}"><code>make_per_unit!</code></a></p><p>For an explanation of <code>ref_extensions</code>, see <a href="../reference/problems.html#PowerModelsDistribution.instantiate_mc_model"><code>instantiate_mc_model</code></a></p><p>For an explanation of <code>map_math2eng_extensions</code>, <code>make_si</code>, <code>make_si_extensions</code>, and <code>dimensionalize_math_extensions</code>, see <a href="../reference/data_models.html#PowerModelsDistribution.solution_make_si-Tuple{Dict{String}, Dict{String}}"><code>solution_make_si</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/a181da565ab1f259e687a996abc9c23aa32aaac5/src/prob/native_pf.jl#L190-L226">source</a></section><section><div><pre><code class="nohighlight hljs">compute_mc_pf(
  pdf::PowerFlowData,
  max_iter::Int,
  stat_tol::Float,
  verbose::Bool
)</code></pre><p>Computes native power flow and requires PowerFlowData.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/a181da565ab1f259e687a996abc9c23aa32aaac5/src/prob/native_pf.jl#L381-L390">source</a></section></article><p><code>compute_mc_pf</code> is based on the current injection method and is inspired by OpenDSS&#39;s algorithm. <code>compute_mc_pf</code> will typically provide an identical result to <code>solve_mc_pf</code>. However, the existence of solution degeneracy around generator injection assignments and multiple power flow solutions can yield different results. The primary advantage of <code>compute_mc_pf</code> over <code>solve_mc_pf</code> is that it does not require building a JuMP model. If the initial point for the Unbalanced Power Flow solution is near-feasible then <code>compute_mc_pf</code> can result in a significant runtime saving by converging quickly and reducing data-wrangling and memory allocation overheads. This initial guess is provided using the standard <code>_start</code> values. The <code>add_start_voltage!</code> function provides a convenient way of setting a suitable starting point.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"></div></div><p>If <code>compute_mc_pf</code> fails to converge try <code>solve_mc_pf</code> instead.</p><p>The table below reports the accuracy of the native power flow with respect to OpenDSS native solver tested on three IEEE testcases: | IEEE testcases | maximum voltage p.u difference with OpenDSS power flow solver | | –––––––-| ––––––––––––––––––––––––––––––- | | IEEE13 | 3.765096388188572e-6 | | IEEE34 | 6.805369850332029e-8 | | IEEE123 | 4.021326251365659e-8 |</p><h3 id="Input-arguments"><a class="docs-heading-anchor" href="#Input-arguments">Input arguments</a><a id="Input-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Input-arguments" title="Permalink"></a></h3><p><code>compute_mc_pf</code> receieves input arguments as follows,</p><ul><li><code>data_math</code> - network data in MATHEMAICAL format</li><li><code>explicit_neutral</code> - a boolean input indication wether or not the nuetral is explicitly modelled</li><li><code>v_start</code> - warm start if different from in-built initialization algorithm</li><li><code>max_iter</code> - maximum itertions</li><li><code>stat_tol</code> - statistical tolerance</li></ul><h3 id="Outputs"><a class="docs-heading-anchor" href="#Outputs">Outputs</a><a id="Outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Outputs" title="Permalink"></a></h3><p><code>compute_mc_pf</code> provides the following outputs,</p><ul><li><code>solution</code> - solution dictionary</li><li><code>iterations</code> - number of iterations</li><li><code>time_build</code> - time spent on building the power flow data</li><li><code>time_solve</code> - time spent on solving the native power flow</li><li><code>time_post</code> - time spent to generate solutions</li><li><code>time_total</code> - total time</li><li><code>termination_status</code> - termination status</li></ul><h3 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h3><p><code>compute_mc_pf</code> has the following limitations,</p><ul><li>starting from the math dictionary means that transformer decomposition is already done, which is different from what OpenDSS does</li><li>we calculate the primitive admittance matrix in p.u. whereas OpenDSS algorithm works with actual units</li><li>no load model relaxation is performed</li><li>inpspired by OpenDSS, we add small ppm values to certain component primitive admittance values to avoid singularity issues</li><li>inpspired by OpenDSS, switch primitive admittance has specific values</li></ul><h2 id="Network-Admittance-Matrix"><a class="docs-heading-anchor" href="#Network-Admittance-Matrix">Network Admittance Matrix</a><a id="Network-Admittance-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Admittance-Matrix" title="Permalink"></a></h2><p>Internally <code>compute_mc_pf</code> utilizes an admittance matrix representation of the network data, which may be useful in other contexts. The foundational type for the admittance matrix representations is <code>SparseMatrixCSC</code>.</p><p>The following function can be used to compute the admittance matrix from PowerModelsDistribution network data.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calc_admittance_matrix" href="#PowerModelsDistribution.calc_admittance_matrix"><code>PowerModelsDistribution.calc_admittance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_admittance_matrix(
  data_math::Dict,
  v_start::Dict,
  explicit_neutral::Bool
)</code></pre><p>Calculates the admittance matrix from PowerFlowData struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/a181da565ab1f259e687a996abc9c23aa32aaac5/src/prob/native_pf.jl#L143-L151">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 5 May 2023 14:31">Friday 5 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
